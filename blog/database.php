<?php
/*
Holds functions pertaining to the database
*/
class Database
{
	/*
		Creates a connection to the database if it does not already exist
		If a connection exists then return that connection
	*/
	public static function connect()
	{
		$dbName = "SENATE";

		//TODO: store this somewhere so that it cannot be accessed except outside the root folder
		//Do not have a empty password for the root user when deployed
		$dbUser = "root";
		$dbPass = "";

		//$conn holds the connection to the database if it has been opened already
		//otherwise, a connection is created and $conn points to that connection
		static $conn;

		//If there is already an existing connection, return that connection
		if ( $conn )
			return $conn;

		$dataSrc = "mysql:host=localhost;dbname={$dbName}";
		try 
		{
			//create the connection with the parameters given
			$conn = new PDO( $dataSrc, $dbUser , $dbPass );
			//make associative arrays the default so that $stmt->fetch() doesn't need PDO::FETCH_ASSOC every time
			$conn->setAttribute( PDO::ATTR_DEFAULT_FETCH_MODE, PDO::FETCH_ASSOC );
		} 
		catch ( PDOException $e ) 
		{
			echo "Error establishing Connection<br>";
			echo "{$e->getMessage()}<br>";
			exit();
		}

		return $conn;
	}

	/*
		Acts as a wrapper around the built in password_hash function.
		So if we ever decide to change how we handle passwords,
			we just have to change the contents of this function.
	*/
	public static function hashPassword( $password )
	{
		return password_hash( $password,  PASSWORD_DEFAULT );
	}

	/*
		Acts as a wrapper around built in password_verify function.
		So if we ever decide to change how we handle passwords,
			we just have to change the contents of this function.
	*/
	public static function samePassword( $password, $hash )
	{
		return password_verify( $password, $hash );
	}

	/*
		Given a username and a password in plain text.
		Returns true if the password is correct for the username provided, or false otherwise.
		Returns false if the username does not exist in the database
	*/
	public static function verifyUser( $username, $password )
	{
		$conn = self::connect();
		$stmt = $conn->prepare( "SELECT password from Users where username=:username" );
		$stmt->bindParam( "username" , $username );
		$stmt->execute();
		$user = $stmt->fetch();
		return ( isset( $user[ "password" ] ) && self::samePassword( $password, $user[ "password" ] ) === TRUE  );
	}

	/*
		Creates a user with the username and password provided in plaintext.
		The password will be hashed before it goes into the database.
		Returns the error code of the query executed, returns five zeros if the query had no errors: 00000
		Does NOT check if the username entered is valid or that it is already taken
	*/
	public static function createUser( $username, $password )
	{
		$username = self::sanitizeData( strtolower( $username ) );
		$password = self::hashPassword( $password );
		$conn = self::connect();
		$stmt = $conn->prepare( "INSERT INTO Users( username, password ) values( :username, :password )" );
		$stmt->bindParam( "username" , $username );
		$stmt->bindParam( "password" , $password );
		$stmt->execute();
		return $conn->errorCode();
	}

	/*
		Returns true if the user with the username provided exists in the Users table, or false otherwise.
	*/
	public static function doesUserExist( $username )
	{
		$username = self::sanitizeData( strtolower( $username ) );
		$conn = self::connect();
		$stmt = $conn->prepare( "SELECT id FROM Users WHERE username=:username" );
		$stmt->bindParam( "username" , $username ); 
		$stmt->execute();
		$row = $stmt->fetch();
		return isset( $row[ "id" ] );
	}

	/*
		Attempts to delete the user from the database.
		Returns an error code that will be 00000 if nothing went wrong.
		This function probably should only be used for testing purposes.
	*/
	public static function deleteUser( $username )
	{
		$username = self::sanitizeData( strtolower( $username ) );
		$conn = self::connect();
		$stmt = $conn->prepare( "DELETE FROM Users WHERE username=:username" );
		$stmt->bindParam( "username" , $username );
		$stmt->execute();
		return $conn->errorCode();
	}

	/*
		Generates a random token for CSRF prevention.
		Length is the number of bytes that will be generated.
		Returns the hexadecimal representation of the generated bytes as a string.
	*/
	public static function randomToken( $length = 32 )
	{
		$strong = false;
		$bytes = openssl_random_pseudo_bytes( $length, $strong );
		//if strong is false, then the bytes were not generated with a cryptographically strong algorithm
		//	if that is the case, then error out
		if ( $strong !== true )
		{
			echo "Could not generate secure token<br>";
			exit();			
		}

		return bin2hex( $bytes );
	}

	/*
		Sanitizes the input given to prevent XSS.
	*/
	public static function sanitizeData( $str )
	{
		return htmlspecialchars( $str, ENT_QUOTES, 'UTF-8', false);		
	}

	/*
		Reverts the input given back to its original form, meaning any HTML tags will be there.
	*/
	public static function unsanitizeData( $str )
	{
		return ( htmlspecialchars_decode( $str, ENT_QUOTES ) );
	}

	/*
		Creates a row for the agenda with the given name and returns the ID for it.
	*/
	public static function createAgenda( $name )
	{
		$name = self::sanitizeData( $name );
		$conn = self::connect();
		$stmt = $conn->prepare( "INSERT INTO Agendas( name, uploadDate, archived ) values( :name, NOW(), 0 )" );
		$stmt->bindParam( "name" , $name ); 
		$stmt->execute();
		return $conn->lastInsertId();		
	}

	/*
		Returns a 2D associative array containing all the information 
			from the Agendas table for the corresponding archived status provided.
		The resulting array is sorted by the upload date, with newer agendas coming before older agendas.
		If archived is 0, returns all agendas that are not archived.
		If archived is 1, returns all agendas that are archived.
	*/
	public static function getAgendas( $archived = 0 )
	{
		$conn = self::connect();
		$stmt = $conn->prepare( "SELECT * FROM Agendas WHERE archived=:archived ORDER BY uploadDate DESC" );
		$stmt->bindParam( "archived" , $archived ); 
		$stmt->execute();
		return $stmt->fetchAll();
	}

	/*
		Returns an array of key value pairs for the row with the id provided that is in the agenda table.
	*/
	public static function getAgendaFromID( $id )
	{
		$conn = self::connect();
		$stmt = $conn->prepare( "SELECT * FROM Agendas WHERE id=:id" );
		$stmt->bindParam( "id" , $id ); 
		$stmt->execute();
		return $stmt->fetch();
	}

	/*
		Returns an array of key value pairs for the most recent agenda from the agendas table.
		
	*/
	public static function getMostRecentAgenda()
	{
		$conn = self::connect();
		$stmt = $conn->prepare( "SELECT * FROM Agendas WHERE archived=0 ORDER BY uploadDate DESC LIMIT 1" );
		$stmt->execute();
		return $stmt->fetch();
	}

	/*
		Archives the agenda with the given id.
		If the id is null, archives all agendas currently in the table.
	*/
	public static function archiveAgenda( $id )
	{
		$conn = self::connect();
		$stmt =  $conn->prepare( "UPDATE Agendas SET archived=1 WHERE id=:id" );
		$stmt->bindParam( "id" , $id );
		$stmt->execute();
		return $conn->errorCode();
	}

	/*
		Archives all agendas currently in the table.
		Returns errorCode, will be 00000 if nothing went wrong.
	*/
	public static function archiveAllAgendas()
	{
		$conn = self::connect();
		$stmt = $conn->prepare( "UPDATE Agendas SET archived=1 WHERE archived=0" );
		$stmt->execute();
		return $conn->errorCode();
	}

	/*
		Removes all agendas from the database that have the corresponding archived value.
		Returns errorCode, will be 00000 if nothing went wrong.
		This function probably should only be used for testing purposes.
	*/
	public static function removeAgendas( $archived = 1 )
	{
		$conn = self::connect();
		$stmt = $conn->prepare( "DELETE FROM Agendas WHERE archived=:archived" );
		$stmt->bindParam( "archived" , $archived ); 
		$stmt->execute();
		return $stmt->errorCode();
	}

	/*
		Creates a blog post with the title and content provided.
		Returns the id of the blog post that was created.
	*/
	public static function createBlogPost( $author, $title, $content )
	{
		$conn = self::connect();
		$str = "INSERT INTO Posts( author, title, content, datePosted ) VALUES( :author, :title, :content, NOW() )";
		$stmt = $conn->prepare( $str );
		$stmt->bindParam( "title" , self::sanitizeData( $title ) );
		$stmt->bindParam( "content" , self::sanitizeData( $content ) );
		$stmt->bindParam( "author" , self::sanitizeData( $author ) );
		$stmt->execute();
		return $conn->lastInsertId();
	}

	/*
		Deletes the blog post with the id provided.
		Returns errorCode, will be 00000 if nothing went wrong.
	*/
	public static function deleteBlogPost( $postID )
	{
		$conn = self::connect();
		$stmt = $conn->prepare( "DELETE FROM Posts WHERE id=:id" );
		$stmt->bindParam( "id" , $postID ); 
		$stmt->execute();
		return $stmt->errorCode();
	}
	
	/*
		Deletes all blog posts currently in the table.
		Should only be used for testing purposes.
		Returns errorCode, will be 00000 if nothing went wrong.
	*/
	public static function deleteAllPosts()
	{
		$conn = self::connect();
		$stmt = $conn->prepare( "DELETE FROM Posts" );
		$stmt->execute();
		return $stmt->errorCode();
	}

	/*
		Returns all the blog posts currently in the table.
		The resulting array is sorted by the creation date, with newer posts coming before older posts.
	*/
	public static function getPosts()
	{
		$conn = self::connect();
		$stmt = $conn->prepare( "SELECT * FROM Posts ORDER BY datePosted DESC,id DESC" );
		$stmt->execute();
		return $stmt->fetchAll();		
	}

	/*
		Returns array containing information on the blog post that has the id provided.
	*/
	public static function getPost( $id )
	{
		$conn = self::connect();
		$stmt = $conn->prepare( "SELECT * FROM Posts WHERE id=:id" );
		$stmt->bindParam( "id" , $id );
		$stmt->execute();
		return $stmt->fetch();
	}

	/*
		Returns the last $limit posts from the blog before the id provided.
		So given an id of 5 and a limit of 2, will return posts that have id of 3 and 4.
		The posts returned are ordered by newer posts coming before older posts.
	*/
	public static function getPostsBeforeID( $id , $limit = 3 )
	{
		$conn = self::connect();
		$stmt = $conn->prepare( "SELECT * FROM Posts WHERE id>:first AND id<:last ORDER by datePosted DESC,id DESC" );
		$stmt->bindParam( "last" , $id );
		$val = ( $id - $limit ) - 1;
		$stmt->bindParam( "first" , $val );
		$stmt->execute();
		return $stmt->fetchAll();
	}

	/*
		Returns array of all the office hours in the hours table for the id provided.
		Using a join would probably be better, but the SQL for this case eludes me.
	*/
	public static function getOfficeHours( $id )
	{
		$conn = self::connect();
		$stmt = $conn->prepare( "SELECT * FROM OfficeHours WHERE RosterID=:id" );
		$stmt->bindParam( "id" , $id );
		$stmt->execute();
		return $stmt->fetchAll();
	}

	/*
		Returns an array that holds the information for all the senators.
		Inside each row is also another array in the hours column that holds the office hours for that senator.
	*/
	public static function getEntireRoster()
	{
		$conn = self::connect();
		$stmt = $conn->prepare( "SELECT id,name,origin,major,letter FROM Roster" );
		$stmt->execute();
		$results = $stmt->fetchAll();
		foreach ( $results as $key=>$row )
		{
			$results[ $key ][ "hours" ] = self::getOfficeHours( $row[ "id" ] );
		}
		return $results;
	}

	/*
		Adds a senator to the Roster with the info provided.
		Returns an error code, either for the insertion of the office hours if something went wrong
			 or for this insertion if something/nothing went wrong with it.
		All the parameters are just strings except for the officeHours which is an array.
		Here is an example of the format for the office hours:
		$office = array();
		$office[] = array( 
			"day" => "wednesday",
			"start" => 8,
			"end" => 12
		);
	*/
	public static function addToRoster( $name, $major, $letter, $origin, $officeHours )
	{
		$conn = self::connect();
		$stmt = $conn->prepare( "INSERT INTO Roster( name, major, letter, origin ) values( :name, :major, :letter, :origin )" );
		$stmt->bindParam( "name" , self::sanitizeData( $name ) );
		$stmt->bindParam( "major" , self::sanitizeData( $major ) );
		$stmt->bindParam( "letter" , self::sanitizeData( $letter ) );
		$stmt->bindParam( "origin" , self::sanitizeData( $origin ) );
		$stmt->execute();
		$error = $stmt->errorCode();
		$id = $conn->lastInsertId();
		$error2 = self::addOfficeHours( $id , $officeHours );
		if ( $error2 !== "00000" )
		{
			return $error2;
		}

		return $error;
	}

	/*
		Adds office hours for the senator with the id provided.	
		Returns an error code if something went wrong with any of the office hours inserted or 00000 otherwise.
		Will stop inserting office hours if along the way one insertion resulted in a non valid error code.
		Here is an example of the format for the office hours:
			$office = array();
			$office[] = array( 
				"day" => "wednesday",
				"start" => 8,
				"end" => 12
			);
		//Offices hours from 3pm(15:00) to 5pm(17:00) on friday:
			$office = array();
			$office[] = array( 
				"day" => "friday",
				"start" => 15,
				"end" => 17
			);
	*/
	private static function addOfficeHours( $id, $officeHours )
	{
		$conn = self::connect();
		foreach( $officeHours as $row )
		{
			$stmt = $conn->prepare( "INSERT INTO OfficeHours( day, startHour, endHour, RosterID ) values( :day, :start, :end, :id )" );
			$stmt->bindParam( "day" , self::sanitizeData( $row[ "day" ] ) );
			$stmt->bindParam( "start" , $row[ "start" ] );
			$stmt->bindParam( "end" , $row[ "end" ] );
			$stmt->bindParam( "id" , $id );
			$stmt->execute();
			$error = $stmt->errorCode();
			if ( $error !== "00000" )
			{
				return $error;
			}	
		}
		return "00000";
	}

	/*
		Deletes all the senators from the Roster table.
		MySQL will also delete their office hours because ON DELETE CASCADE for RosterID in OfficeHours table
		Should only be used for testing purposes/once a year for new senators?
	*/
	public static function clearRoster()
	{
		$conn = self::connect();
		$stmt = $conn->prepare( "DELETE FROM Roster" );
		$stmt->execute();
		return $stmt->errorCode();
	}
}

?>
