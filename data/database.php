<?php
/*
Holds functions pertaining to the database
*/
class Database
{
	/*
		Creates a connection to the database if it does not already exist
		If a connection exists then return that connection
	*/
	public static function connect()
	{
		$dbName = "SENATE";

		//TODO: store this somewhere so that it cannot be accessed except outside the root folder
		//Do not have a empty password for the root user when deployed
		$dbUser = "root";
		$dbPass = "";

		//$conn holds the connection to the database if it has been opened already
		//otherwise, a connection is created and $conn points to that connection
		static $conn;

		//If there is already an existing connection, return that connection
		if ( $conn )
			return $conn;

		$dataSrc = "mysql:host=localhost;dbname={$dbName}";
		try 
		{
			//create the connection with the parameters given
			$conn = new PDO( $dataSrc, $dbUser , $dbPass );
			//make associative arrays the default so that $stmt->fetch() doesn't need PDO::FETCH_ASSOC every time
			$conn->setAttribute( PDO::ATTR_DEFAULT_FETCH_MODE, PDO::FETCH_ASSOC );
		} 
		catch ( PDOException $e ) 
		{
			echo "Error establishing Connection<br>";
			echo "{$e->getMessage()}<br>";
			exit();
		}

		return $conn;
	}

	/*
		Acts as a wrapper around the built in password_hash function.
		So if we ever decide to change how we handle passwords,
			we just have to change the contents of this function.
	*/
	public static function hashPassword( $password )
	{
		return password_hash( $password,  PASSWORD_DEFAULT );
	}

	/*
		Acts as a wrapper around built in password_verify function.
		So if we ever decide to change how we handle passwords,
			we just have to change the contents of this function.
	*/
	public static function samePassword( $password, $hash )
	{
		return password_verify( $password, $hash );
	}

	/*
		Given a username and a password in plain text.
		Returns true if the password is correct for the username provided, or false otherwise.
		Returns false if the username does not exist in the database
	*/
	public static function verifyUser( $username, $password )
	{
		$conn = self::connect();
		$stmt = $conn->prepare( "SELECT password from Users where username=:username" );
		$stmt->bindParam( "username" , $username );
		$stmt->execute();
		$user = $stmt->fetch();
		return ( isset( $user[ "password" ] ) && self::samePassword( $password, $user[ "password" ] ) === TRUE  );
	}

	/*
		Creates a user with the username and password provided in plaintext.
		The password will be hashed before it goes into the database.
		Returns the error code of the query executed, returns five zeros if the query had no errors: 00000
		Does NOT check if the username entered is valid or that it is already taken
	*/
	public static function createUser( $username, $password )
	{
		$username = self::sanitizeData( strtolower( $username ) );
		$password = self::hashPassword( $password );
		$conn = self::connect();
		$stmt = $conn->prepare( "INSERT INTO Users( username, password ) values( :username, :password )" );
		$stmt->bindParam( "username" , $username );
		$stmt->bindParam( "password" , $password );
		$stmt->execute();
		return $conn->errorCode();
	}

	/*
		Returns true if the user with the username provided exists in the Users table, or false otherwise.
	*/
	public static function doesUserExist( $username )
	{
		$username = self::sanitizeData( strtolower( $username ) );
		$conn = self::connect();
		$stmt = $conn->prepare( "SELECT id FROM Users WHERE username=:username" );
		$stmt->bindParam( "username" , $username ); 
		$stmt->execute();
		$row = $stmt->fetch();
		return isset( $row[ "id" ] );
	}

	/*
		Attempts to delete the user from the database.
		Returns an error code that will be 00000 if nothing went wrong.
		This function probably should only be used for testing purposes.
	*/
	public static function deleteUser( $username )
	{
		$username = self::sanitizeData( strtolower( $username ) );
		$conn = self::connect();
		$stmt = $conn->prepare( "DELETE FROM Users WHERE username=:username" );
		$stmt->bindParam( "username" , $username );
		$stmt->execute();
		return $conn->errorCode();
	}

	/*
		Generates a random token for CSRF prevention.
		Length is the number of bytes that will be generated.
		Returns the hexadecimal representation of the generated bytes as a string.
	*/
	public static function randomToken( $length = 32 )
	{
		$strong = false;
		$bytes = openssl_random_pseudo_bytes( $length, $strong );
		//if strong is false, then the bytes were not generated with a cryptographically strong algorithm
		//	if that is the case, then error out
		if ( $strong !== true )
		{
			echo "Could not generate secure token<br>";
			exit();			
		}

		return bin2hex( $bytes );
	}

	/*
		Sanitizes the input given to prevent XSS.
	*/
	public static function sanitizeData( $str )
	{
		return htmlspecialchars( $str, ENT_QUOTES, 'UTF-8', false);		
	}

	/*
		Reverts the input given back to its original form, meaning any HTML tags will be there.
	*/
	public static function unsanitizeData( $str )
	{
		return ( htmlspecialchars_decode( $str, ENT_QUOTES ) );
	}

	/*
		Creates a row for the agenda with the given name and returns the ID for it.
	*/
	public static function createAgenda( $name )
	{
		$name = self::sanitizeData( $name );
		$conn = self::connect();
		$stmt = $conn->prepare( "INSERT INTO Agendas( name, uploadDate, archived ) values( :name, NOW(), 0 )" );
		$stmt->bindParam( "name" , $name ); 
		$stmt->execute();
		return $conn->lastInsertId();		
	}

	/*
		Returns a 2D associative array containing all the information 
			from the Agendas table for the corresponding archived status provided.
		The resulting array is sorted by the upload date, with newer agendas coming before older agendas.
		If archived is 0, returns all agendas that are not archived.
		If archived is 1, returns all agendas that are archived.
	*/
	public static function getAgendas( $archived = 0 )
	{
		$conn = self::connect();
		$stmt = $conn->prepare( "SELECT * FROM Agendas WHERE archived=:archived ORDER BY uploadDate DESC" );
		$stmt->bindParam( "archived" , $archived ); 
		$stmt->execute();
		return $stmt->fetchAll();
	}

	/*
		Archives the agenda with the given id.
		If the id is null, archives all agendas currently in the table.
	*/
	public static function archiveAgenda( $id )
	{
		$conn = self::connect();
		$stmt =  $conn->prepare( "UPDATE Agendas SET archived=1 WHERE id=:id" );
		$stmt->bindParam( "id" , $id );
		$stmt->execute();
		return $conn->errorCode();
	}

	/*
		Archives all agendas currently in the table.
		Returns errorCode, will be 00000 if nothing went wrong.
	*/
	public static function archiveAllAgendas()
	{
		$conn = self::connect();
		$stmt = $conn->prepare( "UPDATE Agendas SET archived=1 WHERE archived=0" );
		$stmt->execute();
		return $conn->errorCode();
	}

	/*
		Removes all agendas from the database that have the corresponding archived value.
		Returns errorCode, will be 00000 if nothing went wrong.
		This function probably should only be used for testing purposes.
	*/
	public static function removeAgendas( $archived = 1 )
	{
		$conn = self::connect();
		$stmt = $conn->prepare( "DELETE FROM Agendas WHERE archived=:archived" );
		$stmt->bindParam( "archived" , $archived ); 
		$stmt->execute();
		return $stmt->errorCode();
	}

	/*
		Creates a blog post with the title and content provided.
		Returns the id of the blog post that was created.
	*/
	public static function createBlogPost( $title, $content )
	{
		$conn = self::connect();
		$str = "INSERT INTO Posts( title, content, datePosted ) VALUES( :title, :content, NOW() )";
		$stmt = $conn->prepare( $str );
		$stmt->bindParam( "title" , self::sanitizeData( $title ) );
		$stmt->bindParam( "content" , self::sanitizeData( $content ) );
		$stmt->execute();
		return $conn->lastInsertId();
	}

	/*
		Deletes the blog post with the id provided.
		Returns errorCode, will be 00000 if nothing went wrong.
	*/
	public static function deleteBlogPost( $postID )
	{
		$conn = self::connect();
		$stmt = $conn->prepare( "DELETE FROM Posts WHERE id=:id" );
		$stmt->bindParam( "id" , $postID ); 
		$stmt->execute();
		return $stmt->errorCode();
	}
	
	/*
		Deletes all blog posts currently in the table.
		Should only be used for testing purposes.
		Returns errorCode, will be 00000 if nothing went wrong.
	*/
	public static function deleteAllPosts()
	{
		$conn = self::connect();
		$stmt = $conn->prepare( "DELETE FROM Posts" );
		$stmt->execute();
		return $stmt->errorCode();
	}

	/*
		Returns all the blog posts currently in the table.
		The resulting array is sorted by the creation date, with newer posts coming before older posts.
	*/
	public static function getPosts()
	{
		$conn = self::connect();
		$stmt = $conn->prepare( "SELECT * FROM Posts ORDER BY datePosted DESC" );
		$stmt->execute();
		return $stmt->fetchAll();		
	}

	/*
		Returns array containing information on the blog post that has the id provided.
	*/
	public static function getPost( $id )
	{
		$conn = self::connect();
		$stmt = $conn->prepare( "SELECT * FROM Posts WHERE id=:id" );
		$stmt->bindParam( "id" , $id );
		$stmt->execute();
		return $stmt->fetch();
	}
}

?>
